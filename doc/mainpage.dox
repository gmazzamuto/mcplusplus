/**
  \mainpage

  \tableofcontents

  \section Introduction Introduction

Numerous areas of science employ Monte Carlo (MC) methods to simulate complex
processes. Light propagation in random media, often referred to as photon
migration, is an area of physics in which such methods are of great importance.
Prime examples include radiative transfer in highly scattering materials such
as biological tissues, clouds, and pharmaceuticals. There, MC simulation is
generally considered the gold standard of modeling and is used to investigate
complex systems and processes, to validate simpler models, as well as to
evaluate data.

Given the complexity of the radiative transfer equation (RTE) -- a widely used
analytical model for light diffusion through turbid media -- approximations
such as the diffusion approximation (DA) are most often used. However these
simplifications do not perform equally well in every situation and they have
their shortcomings. On the other hand the RTE directly follows from energy
conservation. Its derivation is phenomenological, where the complex wave
propagation is reduced to a Poissonian random walk with exponentially
distributed steps between scattering events, with correlations in
directionality given by the phase function. With the computing power available
nowadays, it is possible to implement a Monte Carlo method to find exact
solutions to the RTE, the only approximation being that the number of simulated
photons is finite. This is especially true because this kind of simulations
have an inherently parallel nature and so they can leverage nowadays
multi-threading CPUs and GPUs.

  \section Motivation Motivation

As its name suggests, MCPlusPlus is entirely written in C++. We think that the
Object-oriented programming (OOP) paradigm and the abstraction layer that it
provides apply very well to the problem described above. OOP allows to
encapsulate concepts as reusable objects, thus providing ease of maintenance,
increased code understandability and modular architecture. With this powerful
tool, we can implement a software package that is much more flexible than the
most widely used MC codes, yet having equal to superior performance. The OOP
makes it easy to expand and customize the code, that's why we can provide some
unique features such as:

- customizable photon source (time distribution, k vector distribution)

- time resolved statistics

- resuming a previously run simulation, appending new statistics to it

- granular output in binary format (H5)

  \section HowToInstall How to install

Extract the source tarball and create a new folder that will be used for
compilation. This is called the build folder. Open a terminal in the build
folder and issue the following command:

\code cmake pathToSourceFolder\endcode

where @c pathToSourceFolder is the absolute or relative path to the extracted
source folder. This will prepare the files needed for compilation.

If you wish to specify an installation path different from your system's
default (for example you want to install in @c /home/yourname/local), append
the following option to the command above:

\code -DCMAKE_INSTALL_PREFIX=/home/yourname/local\endcode

If you have dependencies installed in non-standard paths, for example in
@c /home/yourname/local/include/, you can add that path to the @c cmake command
line like this:

\code -DCMAKE_CXX_FLAGS=-I/home/yourname/local/include/\endcode

Once @c cmake has been run, you can build the project and install it in the
specified folder with the following command:

\code make install\endcode

If you installed in a local folder, in order to be able to use the software
you'll have to export the following environment variables in every shell that
you open:

\code
export PATH=/home/yourname/local/bin:$PATH
export LD_LIBRARY_PATH=/home/yourname/local/lib:$LD_LIBRARY_PATH
\endcode

assuming, again, your installation prefix to be @c /home/yourname/local/. You
can also place the two lines above in your shell's configuration file.

*/
